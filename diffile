diff --git a/src/messages/MNVMeofGwBeacon.h b/src/messages/MNVMeofGwBeacon.h
index e04a785ebbf..c0ce7897f55 100644
--- a/src/messages/MNVMeofGwBeacon.h
+++ b/src/messages/MNVMeofGwBeacon.h
@@ -138,7 +138,7 @@ public:
     decode(n, p);
     // Reserve memory for the vector to avoid reallocations
     subsystems.reserve(n); 
-    for (int i; i < n; i++) {
+    for (int i = 0; i < n; i++) {
       NqnState st;
       decode(st.nqn, p);
       for (int i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) {
diff --git a/src/mon/NVMeofGwMap.cc b/src/mon/NVMeofGwMap.cc
index 98fafbc7e79..cc1282676aa 100755
--- a/src/mon/NVMeofGwMap.cc
+++ b/src/mon/NVMeofGwMap.cc
@@ -41,7 +41,7 @@ int  NVMeofGwMap::cfg_add_gw (const GW_ID_T &gw_id, const std::string & nqn, uin
     Gmap[nqn].insert({gw_id, state});
 
     create_metadata(gw_id, nqn);
-    //epoch++;
+    dout(4) << " Add GW :"<< gw_id << "nqn " << nqn << " ANA grpid: " << ana_grpid << dendl;
     return 0;
 }
 
@@ -101,17 +101,19 @@ int NVMeofGwMap::_dump_gwmap(std::stringstream &ss)const  {
 }
 
 
-int NVMeofGwMap::update_active_timers( ){
+int NVMeofGwMap:: update_active_timers( bool &propose_pending ){
 
     dout(4) << __func__  <<  " called  " << mon << dendl;
-
     for (auto& itr : Gmetadata) {
         for (auto& ptr : itr.second) {
-
+            GW_METADATA_T *metadata = &ptr.second;
             for (int i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) {
-                if (ptr.second.anagrp_sm_tstamps[i]  != INVALID_GW_TIMER){
-                    ptr.second.anagrp_sm_tstamps[i] ++;
-                    dout(4) << "timer for GW " << ptr.first << " ANA GRP " << i<<" :" << ptr.second.anagrp_sm_tstamps[i] <<dendl;
+                if (metadata->anagrp_sm_tstamps[i]  != INVALID_GW_TIMER){
+                    metadata->anagrp_sm_tstamps[i] ++;
+                    dout(4) << "timer for GW " << ptr.first << " ANA GRP " << i<<" :" << metadata->anagrp_sm_tstamps[i] <<dendl;
+                    if(metadata->anagrp_sm_tstamps[i] >= 2){//TODO define
+                        fsm_handle_to_expired (ptr.first, itr.first, i, propose_pending);
+                    }
                 }
             }
         }
@@ -141,6 +143,29 @@ int NVMeofGwMap::_dump_active_timers( )const  {
 }
 
 
+int NVMeofGwMap::process_gw_map_gw_down(const GW_ID_T &gw_id, const std::string& nqn,  bool &propose_pending)
+{
+    int rc = 0;
+    int i;
+    GW_STATE_T* gw_state = find_gw_map(gw_id, nqn);
+    if (gw_state) {
+        dout(4) << "GW down " << gw_id << dendl;
+        gw_state->availability = GW_AVAILABILITY_E::GW_UNAVAILABLE;
+        for (i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) {
+            bool map_modified;
+            fsm_handle_gw_down (gw_id, nqn, gw_state->sm_state[i], i, map_modified);
+            if(map_modified) propose_pending = true;
+            gw_state->sm_state[i] = GW_STANDBY_STATE;
+        }
+    }
+    else {
+        dout(4)  << __FUNCTION__ << "ERROR GW-id was not found in the map " << gw_id << dendl;
+        rc = 1;
+    }
+    return rc;
+}
+
+
 int NVMeofGwMap::process_gw_map_ka(const GW_ID_T &gw_id, const std::string& nqn , bool &propose_pending)
 {
     int rc = 0;
@@ -157,7 +182,6 @@ int NVMeofGwMap::process_gw_map_ka(const GW_ID_T &gw_id, const std::string& nqn
             gw_state->availability = GW_AVAILABILITY_E::GW_AVAILABLE;
             for (int i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) gw_state->sm_state[i] = GW_STANDBY_STATE;
             if (gw_state->optimized_ana_group_id != REDUNDANT_GW_ANA_GROUP_ID) { // not a redundand GW
-                //gw_state->ana_state[gw_state->optimized_ana_group_id] = true;
                 gw_state->sm_state[gw_state->optimized_ana_group_id] = GW_ACTIVE_STATE;
             }
             propose_pending = true;
@@ -195,38 +219,8 @@ int NVMeofGwMap::process_gw_map_ka(const GW_ID_T &gw_id, const std::string& nqn
                 }
             }
         }
+        // if GW remains  AVAILABLE need to handle failback Timers , this is handled separately
 
-        else if (gw_state->availability == GW_AVAILABILITY_E::GW_AVAILABLE) {
-           for (int i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++)
-                if (gw_state->sm_state[i] == GW_WAIT_FAILBACK_PREPARED) {
-                    auto timer = get_timer(gw_id, nqn, i);
-                    dout(4)  << "Check timer for Failback from GW " << gw_id << " ANA groupId "<< i << " ticks : " << timer << dendl;
-                    if(timer >= 2){//TODO //mgr_beacon_grace){
-                        //     interval = 2*KATO pased T  so find  the state of the candidate to failback - whether it is still available
-                        cancel_timer(gw_id, nqn, i);
-                        for (auto& itr : *subsyst_it) {
-                            if (itr.second.sm_state[i] == GW_BLOCKED_AGROUP_OWNER && itr.second.availability == GW_AVAILABILITY_E::GW_AVAILABLE) {
-                                gw_state->sm_state[i]  = GW_STANDBY_STATE;
-                                itr.second.sm_state[i] = GW_ACTIVE_STATE;
-                                dout(4)  << "Failback from GW " << gw_id << " to " << itr.first << dendl;
-                                propose_pending = true;
-                                break;
-                            }
-                            else if (itr.second.optimized_ana_group_id == i ){
-                                 if(itr.second.sm_state[i] == GW_STANDBY_STATE  &&  itr.second.availability == GW_AVAILABILITY_E::GW_AVAILABLE) {
-                                          itr.second.sm_state[i] = GW_ACTIVE_STATE; // GW failed and started during the persistency interval
-                                          dout(4)  << "Failback unsuccessfull. GW: " << itr.first << "becomes Active for the ana group " << i  << dendl;
-                                 }
-                                gw_state->sm_state[i] = GW_STANDBY_STATE;
-                                dout(4)  << "Failback unsuccessfull GW: " << gw_id << "becomes standby for the ana group " << i  << dendl;
-                                propose_pending = true;
-                                break;
-                            }
-                        }
-                    }
-                    // maybe there are other ANA groups that this GW is in state GW_WAIT_FAILBACK_PREPARED  so continue pass over all ANA groups
-                }
-        }
     }
     else{
         dout(4)  <<  __func__ << "ERROR GW-id was not found in the map " << gw_id << dendl;
@@ -235,21 +229,23 @@ int NVMeofGwMap::process_gw_map_ka(const GW_ID_T &gw_id, const std::string& nqn
     return rc;
 }
 
-int  NVMeofGwMap::handle_homeless_ana_groups(bool & propose)
+
+int  NVMeofGwMap::handle_abandoned_ana_groups(bool & propose)
 {
+    propose = false;
     for (auto& nqn_itr : Gmap) {
         dout(4) << "NQN " << nqn_itr.first << dendl;
+
         for (auto& ptr : nqn_itr.second) { // loop for GWs inside nqn group
             auto gw_id = ptr.first;
             GW_STATE_T* state = &ptr.second;
 
-            //1. is there is a GW in unavailable state? if yes, is its ANA group handled by some other GW?
+            //1. Failover missed : is there is a GW in unavailable state? if yes, is its ANA group handled by some other GW?
             if (state->availability == GW_AVAILABILITY_E::GW_UNAVAILABLE && state->optimized_ana_group_id != REDUNDANT_GW_ANA_GROUP_ID) {
                 auto found_gw_for_ana_group = false;
                 for (auto& ptr2 : nqn_itr.second) {
                     if (ptr2.second.availability == GW_AVAILABILITY_E::GW_AVAILABLE && ptr2.second.sm_state[state->optimized_ana_group_id] == GW_ACTIVE_STATE) {
-                        found_gw_for_ana_group = true;
-                       // dout(4) << "Found GW " << ptr2.first << " that handles ANA grp " << (int)state->optimized_ana_group_id << dendl;
+                        found_gw_for_ana_group = true; // dout(4) << "Found GW " << ptr2.first << " that handles ANA grp " << (int)state->optimized_ana_group_id << dendl;
                         break;
                     }
                 }
@@ -257,11 +253,12 @@ int  NVMeofGwMap::handle_homeless_ana_groups(bool & propose)
                     dout(4)<< "Was not found the GW " << " that handles ANA grp " << (int)state->optimized_ana_group_id << " find candidate "<< dendl;
 
                     GW_STATE_T* gw_state = find_gw_map(gw_id, nqn_itr.first);
-                    find_failover_candidate( gw_id,  nqn_itr.first , gw_state,  propose );
+                    for (int i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++)
+                        find_failover_candidate( gw_id,  nqn_itr.first , gw_state, i, propose );
                 }
             }
 
-            //2. Check this GW is Available and Standby and no other GW is doing Failback to it
+            //2. Failback missed: Check this GW is Available and Standby and no other GW is doing Failback to it
             else if (state->availability == GW_AVAILABILITY_E::GW_AVAILABLE && state->optimized_ana_group_id != REDUNDANT_GW_ANA_GROUP_ID &&
                       state->sm_state[state->optimized_ana_group_id] == GW_STANDBY_STATE
                     )
@@ -295,21 +292,19 @@ int  NVMeofGwMap::set_failover_gw_for_ANA_group(const GW_ID_T &gw_id, const std:
 
 
 // TODO When decision to change ANA state of group is prepared, need to consider that last seen FSM state is "approved" - means it was returned in beacon alone with map version
-int  NVMeofGwMap::find_failover_candidate(const GW_ID_T &gw_id, const std::string& nqn,  GW_STATE_T* gw_state,  bool &propose_pending)
+int  NVMeofGwMap::find_failover_candidate(const GW_ID_T &gw_id, const std::string& nqn,  GW_STATE_T* gw_state, int grpid,  bool &propose_pending)
 {
    dout(4) <<__func__<< " process GW down " << gw_id << dendl;
 #define ILLEGAL_GW_ID " "
 #define MIN_NUM_ANA_GROUPS 0xFFF
-   int i;
    int min_num_ana_groups_in_gw = 0;
    int current_ana_groups_in_gw = 0;
    GW_ID_T min_loaded_gw_id = ILLEGAL_GW_ID;
    auto subsyst_it = find_subsystem_map(nqn);
 
-    for (i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) {  // this GW may handle several ANA groups and  for each of them need to found the candidate GW
-        if (gw_state->sm_state[i] == GW_ACTIVE_STATE || gw_state->optimized_ana_group_id == i) {
+       // this GW may handle several ANA groups and  for each of them need to found the candidate GW
+        if (gw_state->sm_state[grpid] == GW_ACTIVE_STATE || gw_state->optimized_ana_group_id == grpid) {
             // Find a GW that takes over the ANA group(s)
-
             min_num_ana_groups_in_gw = MIN_NUM_ANA_GROUPS;
             min_loaded_gw_id = ILLEGAL_GW_ID;
             for (auto& itr : *subsyst_it) { // for all the gateways of the subsystem
@@ -335,51 +330,88 @@ int  NVMeofGwMap::find_failover_candidate(const GW_ID_T &gw_id, const std::strin
             }
             if (min_loaded_gw_id != ILLEGAL_GW_ID) {
                 propose_pending = true;
-                set_failover_gw_for_ANA_group(min_loaded_gw_id, nqn, i);
+                set_failover_gw_for_ANA_group(min_loaded_gw_id, nqn, grpid);
             }
-            else
-                propose_pending = false;
-            gw_state->sm_state[i] = GW_STANDBY_STATE;
+            else  propose_pending = false;
+            gw_state->sm_state[grpid] = GW_STANDBY_STATE;
         }
-    }
     return 0;
 }
 
 
-int NVMeofGwMap::process_gw_map_gw_down(const GW_ID_T &gw_id, const std::string& nqn, bool &propose_pending)
-{
+ int NVMeofGwMap::fsm_handle_gw_down    (const GW_ID_T &gw_id, const std::string& nqn, GW_STATES_PER_AGROUP_E state , int grpid, bool &map_modified)
+ {
+    switch (state)
+    {
+        case GW_STANDBY_STATE:
+        case GW_IDLE_STATE:
+         // nothing to do
+        break;
+
+        case GW_WAIT_FAILBACK_PREPARED:
+        {
+           cancel_timer(gw_id, nqn, grpid);
+           auto subsyst_it = find_subsystem_map(nqn);
+           for (auto& itr : *subsyst_it){
+              if (itr.second.sm_state[grpid] == GW_BLOCKED_AGROUP_OWNER) // found GW   that was intended for  Failback for this ana grp
+              {
+                 dout(4) << "Warning: Outgoing Failback when GW is down back - to rollback it" << nqn <<" GW "  <<gw_id << "for ANA Group " << grpid << dendl;
+                itr.second.sm_state[grpid] = GW_STANDBY_STATE;
+                map_modified = true;
+                break;
+              }
+          }
+        }
+        break;    
 
-    int rc = 0;
-    bool found = 0;
-    int i;
-    GW_STATE_T* gw_state = find_gw_map(gw_id, nqn);
-    if (gw_state) {
-        dout(4) << "GW down " << gw_id << dendl;
-        auto subsyst_it = find_subsystem_map(nqn);
-        gw_state->availability = GW_AVAILABILITY_E::GW_UNAVAILABLE;
+        case GW_BLOCKED_AGROUP_OWNER:
+        // nothing to do - let failback timer expire 
+        break;
 
-        for (i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) { //search for outgoing Failback   to ANA group  of this GW
+        case GW_ACTIVE_STATE:
+        {
+            GW_STATE_T* gw_state = find_gw_map(gw_id, nqn);
+            find_failover_candidate( gw_id,  nqn, gw_state, grpid, map_modified);
+        }
+        break;
 
-            for (auto& itr : *subsyst_it){
-                if (gw_state->optimized_ana_group_id == i && itr.second.sm_state[i] == GW_WAIT_FAILBACK_PREPARED){
-                    dout(4) << "Warning: Outgoing Failback when GW is down back - to rollback it" << nqn <<" GW "  <<itr.first << "for ANA Group " << i << dendl;
-                    found = true;
-                    break;
+        default:{
+            ceph_assert(false);
+        }
+
+    }
+    return 0;
+ }
+
+
+int NVMeofGwMap::fsm_handle_to_expired (const GW_ID_T &gw_id, const std::string& nqn, int grpid, bool &map_modified)
+{
+    GW_STATE_T* gw_state = find_gw_map(gw_id, nqn);
+    auto subsyst_it      = find_subsystem_map(nqn);
+    if (gw_state->sm_state[grpid] == GW_WAIT_FAILBACK_PREPARED) {
+
+        dout(4)  << "Expired Failback timer from GW " << gw_id << " ANA groupId "<< grpid <<  dendl;
+
+        cancel_timer(gw_id, nqn, grpid);
+        for (auto& itr : *subsyst_it) {
+            if (itr.second.sm_state[grpid] == GW_BLOCKED_AGROUP_OWNER && itr.second.availability == GW_AVAILABILITY_E::GW_AVAILABLE) {
+                gw_state->sm_state[grpid]  = GW_STANDBY_STATE;
+                itr.second.sm_state[grpid] = GW_ACTIVE_STATE;
+                dout(4)  << "Failback from GW " << gw_id << " to " << itr.first << dendl;
+                map_modified = true;
+                break;
+            }
+            else if (itr.second.optimized_ana_group_id == grpid ){
+                if(itr.second.sm_state[grpid] == GW_STANDBY_STATE  &&  itr.second.availability == GW_AVAILABILITY_E::GW_AVAILABLE) {
+                    itr.second.sm_state[grpid] = GW_ACTIVE_STATE; // GW failed and started during the persistency interval
+                    dout(4)  << "Failback unsuccessfull. GW: " << itr.first << "becomes Active for the ana group " << grpid  << dendl;
                 }
+                gw_state->sm_state[grpid] = GW_STANDBY_STATE;
+                dout(4)  << "Failback unsuccessfull GW: " << gw_id << "becomes standby for the ana group " << grpid  << dendl;
+                map_modified = true;
+                break;
             }
         }
-        if(found){
-            // This GW is reported as down but we werent able to resolve HA at this moment since handling of 2 bad-flows in time  is risky
-            //HA - the GW that takes over would be resolved in polling function handle_homeless_ana_groups
-            propose_pending = false;
-            for (i = 0; i < MAX_SUPPORTED_ANA_GROUPS; i++) {  gw_state->sm_state[i] = GW_STANDBY_STATE;}
-            return rc;
-        }
-        find_failover_candidate( gw_id,  nqn, gw_state,  propose_pending);
     }
-    else {
-        dout(4)  << __FUNCTION__ << "ERROR GW-id was not found in the map " << gw_id << dendl;
-        rc = 1;
-    }
-    return rc;
-}
\ No newline at end of file
+    return 0;
+}
diff --git a/src/mon/NVMeofGwMap.h b/src/mon/NVMeofGwMap.h
index 036dcbe717f..082d3c8b499 100755
--- a/src/mon/NVMeofGwMap.h
+++ b/src/mon/NVMeofGwMap.h
@@ -203,7 +203,7 @@ public:
         }
         return NULL;
     }
-    int   update_active_timers();
+    int   update_active_timers( bool &propose_pending);
     epoch_t get_epoch() const { return epoch; }
     int   _dump_gwmap(GWMAP & Gmap)const;
     int   _dump_gwmap(std::stringstream &ss)const ;
@@ -211,7 +211,7 @@ public:
     int   cfg_add_gw                    (const GW_ID_T &gw_id, const std::string & nqn, uint16_t ana_grpid);
     int   process_gw_map_ka             (const GW_ID_T &gw_id, const std::string& nqn ,  bool &propose_pending);
     int   process_gw_map_gw_down        (const GW_ID_T &gw_id, const std::string& nqn, bool &propose_pending);
-    int   handle_homeless_ana_groups(bool &propose_pending);
+    int   handle_abandoned_ana_groups(bool &propose_pending);
 
     void debug_encode_decode(){
         ceph::buffer::list bl;
@@ -220,7 +220,11 @@ public:
         decode(p);
     }
 private:
-    int  find_failover_candidate(const GW_ID_T &gw_id, const std::string& nqn,  GW_STATE_T* gw_state,  bool &propose_pending);
+    int fsm_handle_gw_down    (const GW_ID_T &gw_id, const std::string& nqn, GW_STATES_PER_AGROUP_E state, int grpid,  bool &map_modified);
+    int fsm_handle_gw_up      (const GW_ID_T &gw_id, const std::string& nqn, GW_STATES_PER_AGROUP_E state, int grpid,  bool &map_modified);
+    int fsm_handle_to_expired (const GW_ID_T &gw_id, const std::string& nqn, int grpid, bool &map_modified);
+
+    int  find_failover_candidate(const GW_ID_T &gw_id, const std::string& nqn,  GW_STATE_T* gw_state, int grpid,  bool &propose_pending);
     int  set_failover_gw_for_ANA_group (const GW_ID_T &gw_id, const std::string& nqn, uint8_t ANA_groupid);
     void publish_map_to_gws(const std::string& nqn){
     }
diff --git a/src/mon/NVMeofGwMon.cc b/src/mon/NVMeofGwMon.cc
index 61bad3f5b10..4bc6a526932 100644
--- a/src/mon/NVMeofGwMon.cc
+++ b/src/mon/NVMeofGwMon.cc
@@ -119,21 +119,21 @@ void NVMeofGwMon::tick(){
         dout(4) << __func__  <<  " NVMeofGwMon leader : " << mon.is_leader() << "active : " << is_active()  << dendl;
         return;
     }
-
+    bool _propose_pending = false;
     inject1();
     const auto now = ceph::coarse_mono_clock::now();
     dout(4) << MY_MON_PREFFIX << __func__  <<  "NVMeofGwMon leader got a real tick, pending epoch "<< pending_map.epoch  << dendl;
     last_tick = now;
-
-    pending_map.update_active_timers( );
     bool propose = false;
-    //if((cnt++ %2) == 0)
-    {
-        pending_map.handle_homeless_ana_groups(propose);
-        if(propose){
-           propose_pending();
-        }
+    pending_map.update_active_timers(propose);
+    _propose_pending |= propose;
+
+    pending_map.handle_abandoned_ana_groups(propose);
+    _propose_pending |= propose;
+    if(_propose_pending){
+       propose_pending();
     }
+
     //TODO pass over the last_beacon map to detect the overdue beacons indicating the GW died
     //if found the one - convert the last_beacon key to  gw_id and nqn and call the function pending_map_process_gw_map_gw_down
     // if propose_pending returned true , call propose_pending method of the paxosService
@@ -289,14 +289,52 @@ bool NVMeofGwMon::preprocess_beacon(MonOpRequestRef op){
     return false; // allways  return false to call leader's prepare beacon
 }
 
+#define GW_DELIM ","
 bool NVMeofGwMon::prepare_beacon(MonOpRequestRef op){
     dout(4) <<  MY_MON_PREFFIX <<__func__  << dendl;
-    //auto m = op->get_req<MMgrBeacon>();
+
     auto m = op->get_req<MNVMeofGwBeacon>();
 
-    dout(4) << "availability " <<  m->get_availability() << " GW : " <<m->get_gw_id() 
-      << " subsystems " << m->get_subsystems() <<  " epoch " << m->get_version() << dendl;
+     //    dout(4) << "availability " <<  m->get_availability() << " GW : " <<m->get_gw_id() << " subsystems " << m->get_subsystems() <<  " epoch " << m->get_version() << dendl;
+    std::stringstream    out;
+    m->print(out);
+    dout(4) << out.str() <<dendl;
+
+    GW_ID_T gw_id = m->get_gw_id();
+    GW_AVAILABILITY_E  avail = m->get_availability();
+    const GwSubsystems& subsystems =  m->get_subsystems();
+    bool propose = false;
+
+    if(avail == GW_AVAILABILITY_E::GW_CREATED){
+        // create gw call cfg_add_gw
+        for (const NqnState& st: subsystems) {
+            pending_map.cfg_add_gw( gw_id, st.nqn, st.opt_ana_gid );
+        }
+    }
+    else if(avail == GW_AVAILABILITY_E::GW_AVAILABLE){
+
+        auto now = ceph::coarse_mono_clock::now();
+        // check pending_map.epoch vs m->get_version() - if different - drop the beacon
+
+        for (const NqnState& st: subsystems) {
+            last_beacon[(gw_id + GW_DELIM + st.nqn)] = now;
+            pending_map.process_gw_map_ka( gw_id, st.nqn, propose );
+        }
+    }
+    else if(avail == GW_AVAILABILITY_E::GW_UNAVAILABLE){ // state set by GW client application
+        //  TODO: remove from last_beacon if found . if gw was found in last_beacon call process_gw_map_gw_down
+        for (const NqnState& st: subsystems) {
+
+            auto it = last_beacon.find(gw_id + GW_DELIM + st.nqn);
+            if (it != last_beacon.end()){
+                  last_beacon.erase(gw_id + GW_DELIM + st.nqn);
+                  pending_map.process_gw_map_gw_down( gw_id, st.nqn, propose );
+            }
+        }
+    }
+    if (propose)
+      return true;
 
-    //last_beacon[m->get_gid()] = ceph::coarse_mono_clock::now();
-    return false; // if no changes are need in the map
+    else 
+     return false; // if no changes are need in the map
 }
